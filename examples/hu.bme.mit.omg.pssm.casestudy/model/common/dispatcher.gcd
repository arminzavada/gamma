package dispatchers

import "interfaces"

statechart DispatcherSC [
	port dispatcherControlActivity_0 : requires ActivityDispatcherControl
	port dispatcherControl : requires DispatcherControl
	port inputData : requires Data
	
	port queueControl : provides QueueControl	
	port outputData : provides Data	
	port outputDataActivity_0 : provides Data
] {
	
	var activity_0_Start : integer := 0
	var activity_0_AnotherSignal : integer := 0
	var activity_0_Continue : integer := 0
	var activity_0_Pending : integer := 0
	
	region Main {
		initial Initial
		state WaitingForEvent {
			entry / raise queueControl.next;
		}
		state WaitingForTarget {
			region Sent {
				initial IgnoreInitial
				state IgnoreState
				
				state Sent_Start
				choice DecideActivity_Start
				merge MergeActivity_Start
				
				state Sent_AnotherSignal
				choice DecideActivity_AnotherSignal
				merge MergeActivity_AnotherSignal
				
				state Sent_Continue
				choice DecideActivity_Continue
				merge MergeActivity_Continue
				
				state Sent_Pending
				choice DecideActivity_Pending
				merge MergeActivity_Pending
			}
		}
	}
	
	region EventSubscription {
		initial EventSubscriptionInitial
		state ListeningToSubscriptions
	}
	
	transition from Initial to WaitingForEvent
	
	// dispatching incoming start event
	transition from WaitingForEvent to WaitingForEvent when inputData.start [activity_0_Start > 0] / raise outputDataActivity_0.start; activity_0_Start := activity_0_Start - 1; // send to activity_0
	transition from WaitingForEvent to Sent_Start when inputData.start / raise outputData.start; // send to statechart
	transition from Sent_Start to DecideActivity_Start when dispatcherControl.ignore // statechart did not match
	transition from DecideActivity_Start to MergeActivity_Start [activity_0_Start > 0] / raise outputDataActivity_0.start; activity_0_Start := activity_0_Start - 1; // send to activity_0
	transition from DecideActivity_Start to MergeActivity_Start [else] // throw away event
	transition from MergeActivity_Start to WaitingForEvent
	
	// dispatching incoming anotherSignal event
	transition from WaitingForEvent to WaitingForEvent when inputData.anotherSignal [activity_0_AnotherSignal > 0] / raise outputDataActivity_0.anotherSignal; activity_0_AnotherSignal := activity_0_AnotherSignal - 1;
	transition from WaitingForEvent to Sent_AnotherSignal when inputData.anotherSignal / raise outputData.anotherSignal; // send to statechart
	transition from Sent_AnotherSignal to DecideActivity_AnotherSignal when dispatcherControl.ignore // statechart did not match
	transition from DecideActivity_AnotherSignal to MergeActivity_AnotherSignal [activity_0_AnotherSignal > 0] / raise outputDataActivity_0.anotherSignal; activity_0_AnotherSignal := activity_0_AnotherSignal - 1; // send to activity_0
	transition from DecideActivity_AnotherSignal to MergeActivity_AnotherSignal [else] // throw away event
	transition from MergeActivity_AnotherSignal to WaitingForEvent
	
	// dispatching incoming continue event
	transition from WaitingForEvent to WaitingForEvent when inputData.continue [activity_0_Continue > 0] / raise outputDataActivity_0.continue; activity_0_Continue := activity_0_Continue - 1;
	transition from WaitingForEvent to Sent_Continue when inputData.continue / raise outputData.continue; // send to statechart
	transition from Sent_Continue to DecideActivity_Continue when dispatcherControl.ignore // statechart did not match
	transition from DecideActivity_Continue to MergeActivity_Continue [activity_0_Continue > 0] / raise outputDataActivity_0.continue; activity_0_Continue := activity_0_Continue - 1; // send to activity_0
	transition from DecideActivity_Continue to MergeActivity_Continue [else] // throw away event
	transition from MergeActivity_Continue to WaitingForEvent
	
	// dispatching incoming continue event
	transition from WaitingForEvent to WaitingForEvent when inputData.pending [activity_0_Pending > 0] / raise outputDataActivity_0.pending; activity_0_Pending := activity_0_Pending - 1;
	transition from WaitingForEvent to Sent_Pending when inputData.pending / raise outputData.pending; // send to statechart
	transition from Sent_Pending to DecideActivity_Pending when dispatcherControl.ignore // statechart did not match
	transition from DecideActivity_Pending to MergeActivity_Pending [activity_0_Pending > 0] / raise outputDataActivity_0.pending; activity_0_Pending := activity_0_Pending - 1; // send to activity_0
	transition from DecideActivity_Pending to MergeActivity_Pending [else] // throw away event
	transition from MergeActivity_Pending to WaitingForEvent
	
	// statechart processed this event
	transition from WaitingForTarget to WaitingForEvent when dispatcherControl.ready
	
	transition from IgnoreInitial to IgnoreState // ignored
	
	// processing event subscriptions
	transition from EventSubscriptionInitial to ListeningToSubscriptions / ResetActivity_0();
	transition from ListeningToSubscriptions to ListeningToSubscriptions when dispatcherControlActivity_0.resetSubscriptions / ResetActivity_0();
	transition from ListeningToSubscriptions to ListeningToSubscriptions when dispatcherControlActivity_0.start / activity_0_Start := activity_0_Start + 1;
	transition from ListeningToSubscriptions to ListeningToSubscriptions when dispatcherControlActivity_0.anotherSignal / activity_0_AnotherSignal := activity_0_AnotherSignal + 1;
	transition from ListeningToSubscriptions to ListeningToSubscriptions when dispatcherControlActivity_0.continue / activity_0_Continue := activity_0_Continue + 1;
	transition from ListeningToSubscriptions to ListeningToSubscriptions when dispatcherControlActivity_0.pending / activity_0_Pending := activity_0_Pending + 1;
	
	procedure ResetActivity_0 : void {
		activity_0_Start := 0;
		activity_0_AnotherSignal := 0;
		activity_0_Continue := 0;
		activity_0_Pending := 0;
	}
	
}

adapter Dispatcher of component dispatcher : DispatcherSC {	
	when any / run
	
	queue activityControlMessages(priority = 3, capacity = 10) {
		dispatcherControlActivity_0.any
	}
	queue controlMessages(priority = 2, capacity = 1) {
		dispatcherControl.any
	}
	queue dataMessages(priority = 1, capacity = 1) {
		inputData.any
	}
}
