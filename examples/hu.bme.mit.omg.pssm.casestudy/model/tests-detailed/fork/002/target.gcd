package target

import "interfaces"
import "activities"
import "dispatchers"
 
scheduled-async System {
	component messageQueue : MessageQueue
	component target : Target
	component dispatcher : Dispatcher
	
	// Hooking up MessageQueue
	channel [ dispatcher.queueControl ] -o)- [ messageQueue.queueControl ]
	channel [ messageQueue.data ] -o)- [ dispatcher.inputData ]
	
	// Hooking up target
	channel [ dispatcher.outputData ] -o)- [ target.data ]
	channel [ target.dispatcherControl ] -o)- [ dispatcher.dispatcherControl ]
	
	// Initialize by executing the Dispatcher component
	initial execute dispatcher
} 

@Asynchronous
statechart MessageQueue [
	port queueControl : requires QueueControl
	
	port data : provides Data
] {
	
	region Main {
		initial Initial
		state _0
		state _1
	}
	
	transition from Initial to _0
	transition from _0 to _1 when queueControl.next / raise data.start;
	
}

@RegionSchedule=bottom-up
statechart TargetSC [
	port data : requires Data
	
	port dispatcherControl : provides DispatcherControl
	
	port completion_s1 : provides StatechartCompletion
	port completion_s1_1 : provides StatechartCompletion
	port completion_s1_11 : provides StatechartCompletion
	port completion_s1_12 : provides StatechartCompletion
	port completion_s1_1_1 : provides StatechartCompletion
	port completion_s1_2_1 : provides StatechartCompletion
] {	
	
	region Wrapper {
		initial WrapperInitial
		state WrapperFunction {
			region Main {
				initial Initial
				state wait
				state S1 {
					entry / log "S1_entry";
					region S1Region {
						initial S1Initial
						fork Fork
						state S1_1 {
							entry / log "S1_1_entry";
							region S1_1Region {
								initial S1_1Initial
								state S1_1_1 {
									entry / raise completion_s1_1_1.completion;
								}
								state S1_1Final {
									entry / raise completion_s1_11.completion;
								}
							}
							region S1_2Region {
								initial S1_2Initial
								state S1_2_1 {
									entry / raise completion_s1_2_1.completion;
								}
								state S1_2Final {
									entry / raise completion_s1_12.completion;
								}
							}
							region S1_1CompletionListener {
								initial S1_1CompletionListener_Initial
								state S1_1CompletionListener_Waiting
								state S1_1CompletionListener_S1_1Final
								state S1_1CompletionListener_S1_2Final
								state S1_1CompletionListener_Done {
									entry / raise completion_s1_1.completion; 
								}
							}
						}
						state S1Final {
							entry / raise completion_s1.completion;
						}
					}
				}
				state Final
			}
		}
	}
	
	transition from WrapperInitial to WrapperFunction
	
	@Internal
	transition from WrapperFunction to WrapperFunction when data.any / raise dispatcherControl.ignore; // default ignore, without exit-entry
	
	transition "T1" from Initial to wait
	transition "T2" from wait to Fork when data.start / log "T2_effect"; raise dispatcherControl.ready;
	
	transition "T2_1" from Fork to S1_1_1 / log "T2_1_effect";
	transition "T2_2" from Fork to S1_2_1 / log "T2_2_effect";
	
	transition from S1Initial to S1_1
	
	transition from S1_1Initial to S1_1_1
	transition "T2_3" from S1_1_1 to S1_1Final when completion_s1_1_1.completion
		
	transition from S1_2Initial to S1_2_1
	transition "T2_4" from S1_2_1 to S1_2Final when completion_s1_2_1.completion
		
	transition from S1_1CompletionListener_Initial to S1_1CompletionListener_Waiting
	transition from S1_1CompletionListener_Waiting to S1_1CompletionListener_S1_1Final when completion_s1_11.completion
	transition from S1_1CompletionListener_Waiting to S1_1CompletionListener_S1_2Final when completion_s1_12.completion
	transition from S1_1CompletionListener_S1_1Final to S1_1CompletionListener_Done when completion_s1_12.completion
	transition from S1_1CompletionListener_S1_2Final to S1_1CompletionListener_Done when completion_s1_11.completion
		
	transition "T2_5" from S1_1 to S1Final when completion_s1_1.completion
	transition "T3" from S1 to Final when completion_s1.completion
	
}

adapter Target of component target : TargetSC {
	when any / run
	
	queue completionQueue(priority = 2, capacity = QUEUE_SIZE) {
		completion_s1.any,
		completion_s1_1.any,
		completion_s1_11.any,
		completion_s1_12.any,
		completion_s1_1_1.any,
		completion_s1_2_1.any
	}
	queue dataQueue(priority = 1, capacity = QUEUE_SIZE) {
		data.any
	}
}
