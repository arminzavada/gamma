package target

import "interfaces"
import "simple_activities"
import "dispatchers"
 
scheduled-async System {
	
	component eventQueue : EventQueue
	component target : Target
	component dispatcher : Dispatcher
	component doActivity_0 : DoActivity
	
	// Tester controlling - next, end
	channel [ dispatcher.queueControl ] -o)- [ eventQueue.queueControl ]
	
	// Actual target data propagation
	channel [ eventQueue.data ] -o)- [ dispatcher.inputData ]
	channel [ dispatcher.outputData ] -o)- [ target.data ]
	
	// Scheduler controlling - ready, ignore
	channel [ target.dispatcherControl ] -o)- [ dispatcher.dispatcherControl ]
	
	// Hooking up doActivity_0
	channel [ doActivity_0.controller ] -o)- [ target.activity_0 ]
	channel [ doActivity_0.dispatcherControl ] -o)- [ dispatcher.dispatcherControlActivity_0 ]
	channel [ dispatcher.outputDataActivity_0 ] -o)- [ doActivity_0.data ]

	initial execute dispatcher

}

@Asynchronous
statechart EventQueue [
	port queueControl : requires QueueControl
	
	port data : provides Data
] {
	
	region Main {
		initial Initial
		state _0
		state _1
	}
	
	transition from Initial to _0
	transition from _0 to _1 when queueControl.next / raise data.start;
	
}

@RegionSchedule=bottom-up
statechart TargetSC [
	port activity_0 : requires ActivityControllerInterface
	port data : requires Data
	
	port dispatcherControl : provides DispatcherControl
	
	port completion_s1 : provides StatechartCompletion
	port completion_s2_1 : provides StatechartCompletion
	port completion_s2final : provides StatechartCompletion
	port completion_s3_1 : provides StatechartCompletion
	port completion_s3_1_1 : provides StatechartCompletion
	port completion_s3_1final : provides StatechartCompletion
	port completion_s3final : provides StatechartCompletion
] {
		
	region Wrapper {
		initial WrapperInitial
		state WrapperFunction {
			region Main {
				initial Initial
				state waiting
				state S1 {
					region S2Region {
						initial S2Initial
						state S2_1 {
							entry / raise completion_s2_1.completion;
						}
						state S2Final {
							entry / raise completion_s2final.completion;
						}
					}
					region S3Region {
						initial S3Initial
						state S3_1 {
							entry / raise activity_0.control(true);
							exit / raise activity_0.control(false);
							region S3_1Region {
								initial S3_1Initial
								state S3_1_1 {
									entry / raise completion_s3_1_1.completion;
								}
								state S3_1Final {
									entry / raise completion_s3_1final.completion;
								}
							}
							region S3_1CompletionListener {
								initial S3_1CompletionListener_Initial
								state S3_1CompletionListener_Waiting
								state S3_1CompletionListener_activity_0
								state S3_1CompletionListener_S3_1Final
								state S3_1CompletionListener_Done {
									entry / raise completion_s3_1.completion; 
								}
							}
						}
						state S3Final {
							entry / raise completion_s3final.completion;
						}
					}
					region S1CompletionListener {
						initial S1CompletionListener_Initial
						state S1CompletionListener_Waiting
						state S1CompletionListener_S2Final
						state S1CompletionListener_S3Final
						state S1CompletionListener_Done {
							entry / raise completion_s1.completion; 
						}
					}
				}
				state Final
			}
		}
	}
	
	transition from WrapperInitial to WrapperFunction
	
	@Internal
	transition from WrapperFunction to WrapperFunction when data.any / raise dispatcherControl.ignore; // default ignore, without exit-entry
		
	transition from Initial to waiting
	transition from waiting to S1 when data.start / raise dispatcherControl.ready;
	
	transition from S2Initial to S2_1
	transition from S2_1 to S2Final when completion_s2_1.completion
	
	transition from S3Initial to S3_1
	transition from S3_1Initial to S3_1_1
	transition from S3_1_1 to S3_1Final when completion_s3_1_1.completion
	
	// Handling composite completion events for S3_1
	transition from S3_1CompletionListener_Initial to S3_1CompletionListener_Waiting
	transition from S3_1CompletionListener_Waiting to S3_1CompletionListener_activity_0 when activity_0.done
	transition from S3_1CompletionListener_Waiting to S3_1CompletionListener_S3_1Final when completion_s3_1final.completion
	transition from S3_1CompletionListener_activity_0 to S3_1CompletionListener_Done when completion_s3_1final.completion
	transition from S3_1CompletionListener_S3_1Final to S3_1CompletionListener_Done when activity_0.done
	
	transition from S3_1 to S3Final when completion_s3_1.completion
	
	// Handling composite completion events for S1
	transition from S1CompletionListener_Initial to S1CompletionListener_Waiting
	transition from S1CompletionListener_Waiting to S1CompletionListener_S2Final when completion_s2final.completion
	transition from S1CompletionListener_Waiting to S1CompletionListener_S3Final when completion_s3final.completion
	transition from S1CompletionListener_S2Final to S1CompletionListener_Done when completion_s3final.completion
	transition from S1CompletionListener_S3Final to S1CompletionListener_Done when completion_s2final.completion
	
	transition from S1 to Final when completion_s1.completion
	
}

adapter Target of component target : TargetSC {
	when any / run
	
	queue completionQueue(priority = 2, capacity = QUEUE_SIZE) {
		activity_0.done,
		completion_s1.any,
		completion_s2_1.any,
		completion_s2final.any,
		completion_s3_1.any,
		completion_s3_1_1.any,
		completion_s3_1final.any,
		completion_s3final.any
	}
	queue dataQueue(priority = 1, capacity = QUEUE_SIZE) {
		data.any
	}
}
